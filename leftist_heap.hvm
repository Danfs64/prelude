// Leftist Heap implementation based on Okasaki's book

// From (Okasaki, 1998): "Leftist heaps are heap-ordered binary trees that satisfy the
// leftist property: the rank of any left child is at least as large as the rank of its
// right sibling. The rank of a node is defined to be the length of its right spine
// (i.e., the rightmost path from the node in question to an empty node). A simple
// consequence of the leftist property is that the right spine of any node is always
// the shortest path to an empty node" 

// The Tree constructor takes 4 parametres: rank, content, left subtree/empty
// and right subtree/empty

// Merges two trees. Merge is called recursively on the right subtree of the tree with 
// the smallest content and the other tree. MakeT is a helper function which swaps two
// sibling trees to maintain the leftist property
(LHeap.merge h Empty) = h
(LHeap.merge Empty h) = h
(LHeap.merge (Tree _ x a1 b1) (Tree _ y a2 b2)) = (MergeAux (<= x y) (Tree _ x a1 b1) (Tree _ y a2 b2))
    (MergeAux 1 (Tree _ x a1 b1) (Tree _ y a2 b2)) = (MakeT x a1 (LHeap.merge b1 (Tree _ y a2 b2)))
    (MergeAux 0 (Tree _ x a1 b1) (Tree _ y a2 b2)) = (MakeT y a2 (LHeap.merge (Tree _ x a1 b1) b2))

(Rank Empty) = 0
(Rank (Tree r _ _ _)) = r

// Helper function to Merge. Creates a tree and swaps the subtrees if needed to 
// maintain the leftist property
(MakeT x a b) = (MakeTAux (>= (Rank a) (Rank b)) x a b)
    (MakeTAux 1 x a b) = (Tree (+ (Rank b) 1) x a b)
    (MakeTAux 0 x a b) = (Tree (+ (Rank a) 1) x b a)

(LHeap.insert x h) = (LHeap.merge (Tree 1 x Empty Empty) h)

(LHeap.findMin (Tree _ x _ _)) = x

(LHeap.deleteMin (Tree _ x a b)) = (LHeap.merge a b)

// Generates a leftist heap from a list
(LHeap.fromList Nil) = Empty
(LHeap.fromList (Cons x xs)) = (LHeap.merge (LHeap.insert x Empty) (LHeap.fromList xs))

(Main) = (LHeap.fromList [1,2,5,4,3])