//* Binomial Heap

// A Binomial Heap is represented as a list of tree nodes, ordered crescently on rank

// A tree node of a Binomial Heap is composed of:
//   - Its rank, which determines its size and how many children it has;
//   - Its root value, which is lower than the values from its children (The min-heap property);
//   - Its children, represented as a list of tree nodes.

// Based on Chris Okasaki's "Purely Functional Data Structures", Chapter 6.2.2 - 1996

//* Type definitions:
// type List<A: Type> {
//     List.Nil
//     List.Cons(head: A, tail: List<A>)
// }

// type Node<Key: Type> {
//     (rank: Nat, root: Key, children: List<Node<Key>>)
// }

// type Heap<Key> = List<Node<Key>>

// type Maybe<A: Type> {
//     Maybe.None
//     Maybe.Some(value: A)
// }

// type Pair<A: Type, B: Type> {
//    (fst: A, snd: B)
// }


//* Helper Functions

(Nat.min x y) = (Nat.min.aux (<= x y) x y)
    (Nat.min.aux 1 x y) = x
    (Nat.min.aux 0 x y) = y

(List.reverse ls) = (List.reverse.aux ls Nil)
    (List.reverse.aux  Nil        acc) = acc
    (List.reverse.aux (Cons x xs) acc) = (List.reverse.aux xs (Cons x acc))

(Pair.fst (Pair fst _)) = fst
(Pair.snd (Pair _ snd)) = snd

(Pair.apply (Pair fst snd) fn) = (fn fst snd)

// Decides if x is Greater, Lesser, or Equal to y
(Battleship x y) = (Battleship.aux (< x y) (> x y))
    (Battleship.aux 1 _) = Lesser
    (Battleship.aux 0 1) = Greater
    (Battleship.aux 0 0) = Equal

// Decreasing Range:
// Creates a range from n-1 to 0
(DecRange 0) = Nil
(DecRange n) =
    let dec = (- n 1)
    (Cons dec (DecRange dec))


//* "Getters"

// Rank(n: Node<Key>) -> Pair<Nat, Node<Key>>
(Node.rank (Node rank root children)) = (Pair rank (Node rank root children))
// Root(n: Node<Key>) -> Pair<Key, Node<Key>>
(Node.root (Node rank root children)) = (Pair root (Node rank root children))
// Children(n: Node<Key>) -> Heap<Key>
(Node.children (Node rank root children)) = children
// Children(n: Node<Key>) -> Pair<Heap<Key>, Node<Key>>
// (Node.children (Node rank root children)) = (Pair children (Node rank root children))

(Node.rank_root (Node rank root children)) = (Pair rank root)

//* Heap Functions

// Links together two trees with the same rank
// The tree returned will be the tree with smaller root with:
//   - the other tree as one of its children
//   - its rank increased by 1
// Link(n1: Node, n2: Node) -> Node
(Heap.link n1 n2) =
    (Pair.apply (Node.root n1) @n1_root @n1_copy
    (Pair.apply (Node.root n2) @n2_root @n2_copy
    (Heap.link.aux (<= n1_root n2_root) n1_copy n2_copy)))

(Heap.link.aux 1 (Node r1 x1 c1) n2) = (Node (+ r1 1) x1 (Cons n2 c1))
(Heap.link.aux 0 n1 (Node r2 x2 c2)) = (Node (+ r2 1) x2 (Cons n1 c2))

// Inserts a Tree into the heap
// P.S.: Do not call it manually, you could break the heap structure
// InsertTree(new: Node, pq: Heap) -> Heap
(InsertTree new  Nil)        = (Cons new Nil)
(InsertTree new (Cons x xs)) =
    (Pair.apply (Node.rank new) @new_rank @new_copy
    (Pair.apply (Node.rank x)   @x_rank   @x_copy 
    (InsertTree.aux (< new_rank x_rank) new_copy (Cons x_copy xs))))

(InsertTree.aux 1 new  xs        ) = (Cons new xs)
(InsertTree.aux 0 new (Cons x xs)) = (InsertTree (Heap.link new x) xs)

// Inserts a key into the heap
// It does so by creating a Node with the key and calling InsertTree
// Insert(x: Key, pq: Heap<Key>) -> Heap<Key>
(Heap.insert x pq) = (InsertTree (Node 0 x Nil) pq)

// Merge together two heaps
// Merge(pq1: Heap, pq2: Heap) -> Heap
(Heap.merge pq Nil) = pq
(Heap.merge Nil pq) = pq
(Heap.merge (Cons x xs) (Cons y ys)) =
    (Pair.apply (Node.rank x) @x_rank @x_copy
    (Pair.apply (Node.rank y) @y_rank @y_copy
    (Heap.merge.aux
        (Battleship x_rank y_rank)
        (Cons x_copy xs)
        (Cons y_copy ys)
    )))

(Heap.merge.aux Lesser  (Cons x xs) (Cons y ys)) = (Cons x (Heap.merge xs (Cons y ys)))
(Heap.merge.aux Greater (Cons x xs) (Cons y ys)) = (Cons y (Heap.merge (Cons x xs) ys))
(Heap.merge.aux Equal   (Cons x xs) (Cons y ys)) = (InsertTree (Heap.link x y) (Heap.merge xs ys))

// Finds the node which contains the minimal value of the heap
// Returns the rank and root (key) of the node
// Raises an error on a empty heap
// FindMinNode(pq: Heap<Key>) -> Pair<Nat, Key>
(Heap.findMinNode  Nil       ) = Error.EmptyHeap
(Heap.findMinNode (Cons x xs)) =
    (Heap.findMinNode.aux xs (Node.rank_root x))

(Heap.findMinNode.aux  Nil        min_pair) = min_pair
(Heap.findMinNode.aux (Cons x xs) min_pair) =
    (Pair.apply (Node.rank_root x) @x_rank @x_root
    (Heap.findMinNode.aux2 (< x_root (Pair.fst min_pair)) xs min_pair (Pair x_rank x_root)))

(Heap.findMinNode.aux2 1 xs min_pair x_pair) = (Heap.findMinNode.aux xs   x_pair)
(Heap.findMinNode.aux2 0 xs min_pair x_pair) = (Heap.findMinNode.aux xs min_pair)

// Finds the minimal element of the heap
// Returns Maybe.none if the heap is empty
// FindMin(pq: Heap<Key>) -> Maybe<Key>
(Heap.findMin Nil) = Maybe.None
(Heap.findMin xs ) =
    let min_node_root = (Pair.snd (Heap.findMinNode xs))
    (Maybe.Some min_node_root)

// Removes the minimal element of the heap
// Returns an empty heap if the heap is already empty
// DeleteMin(pq: Heap) -> Heap
(Heap.deleteMin Nil) = Nil
(Heap.deleteMin pq ) =
    let rank_to_remove = (Pair.fst (Heap.findMinNode pq))
    let get_min        = (Heap.removeRank pq rank_to_remove)
    (Pair.apply get_min @removed @new_pq
    (Heap.merge (List.reverse (Node.children removed)) new_pq))

// Finds the node with a specific rank
// Returns that node and the heap without it
(Heap.removeRank (Cons x xs) rank) =
    (Pair.apply (Node.rank x) @x_rank @x_copy
    (Heap.removeRank.aux (== x_rank rank) (Cons x_copy xs) rank))

(Heap.removeRank.aux 1 (Cons x xs) rank) = (Pair x xs)
(Heap.removeRank.aux 0 (Cons x xs) rank) =
    let rec = (Heap.removeRank xs rank)
    (Pair.apply rec @node @pq
    (Pair node (Cons x pq)))

// Creates a heap using a list of natural numbers
// Heap.fromList(xs: List<Key>) -> Heap<Key>
(Heap.fromList xs) = (Heap.fromList.aux xs Nil)
    (Heap.fromList.aux  Nil        pq) = pq
    (Heap.fromList.aux (Cons x xs) pq) = (Heap.fromList.aux xs (Heap.insert x pq))

// Deletes the 'n' minimal values from the heap
// DeleteMin.repeat(n: Nat, pq: Heap) -> Heap
(Heap.deleteMin.repeat 0 pq) = pq
(Heap.deleteMin.repeat n pq) =
    let dec = (- n 1)
    let pq2 = (Heap.deleteMin pq)
    (Heap.deleteMin.repeat dec pq2)


(Main) =
    // Some vars
    // let heap1 = (Heap.fromList [1,2,3,4,5])
    // let heap2 = (Heap.fromList [6,7,8,9,10,11,12])
    // let heap3 = (Heap.fromList [0,13,14,15,16,17])
    // let heapmaster = (Heap.merge heap3 (Heap.merge heap1 heap2))
    // let heapmaster = [(Node 1 16 [(Node 0 17 [])]), (Node 4 0 [(Node 3 1 [(Node 2 6 [(Node 1 8 [(Node 0 9 [])]), (Node 0 7 [])]), (Node 1 3 [(Node 0 4 [])]), (Node 0 2 [])]), (Node 2 5 [(Node 1 10 [(Node 0 11 [])]), (Node 0 12 [])]), (Node 1 14 [(Node 0 15 [])]), (Node 0 13 [])])]
    let heap0_99 = [(Node 2 0 [(Node 1 2 [(Node 0 3 [])]), (Node 0 1 [])]), (Node 5 4 [(Node 4 20 [(Node 3 28 [(Node 2 32 [(Node 1 34 [(Node 0 35 [])]), (Node 0 33 [])]), (Node 1 30 [(Node 0 31 [])]), (Node 0 29 [])]), (Node 2 24 [(Node 1 26 [(Node 0 27 [])]), (Node 0 25 [])]), (Node 1 22 [(Node 0 23 [])]), (Node 0 21 [])]), (Node 3 12 [(Node 2 16 [(Node 1 18 [(Node 0 19 [])]), (Node 0 17 [])]), (Node 1 14 [(Node 0 15 [])]), (Node 0 13 [])]), (Node 2 8 [(Node 1 10 [(Node 0 11 [])]), (Node 0 9 [])]), (Node 1 6 [(Node 0 7 [])]), (Node 0 5 [])]), (Node 6 36 [(Node 5 68 [(Node 4 84 [(Node 3 92 [(Node 2 96 [(Node 1 98 [(Node 0 99 [])]), (Node 0 97 [])]), (Node 1 94 [(Node 0 95 [])]), (Node 0 93 [])]), (Node 2 88 [(Node 1 90 [(Node 0 91 [])]), (Node 0 89 [])]), (Node 1 86 [(Node 0 87 [])]), (Node 0 85 [])]), (Node 3 76 [(Node 2 80 [(Node 1 82 [(Node 0 83 [])]), (Node 0 81 [])]), (Node 1 78 [(Node 0 79 [])]), (Node 0 77 [])]), (Node 2 72 [(Node 1 74 [(Node 0 75 [])]), (Node 0 73 [])]), (Node 1 70 [(Node 0 71 [])]), (Node 0 69 [])]), (Node 4 52 [(Node 3 60 [(Node 2 64 [(Node 1 66 [(Node 0 67 [])]), (Node 0 65 [])]), (Node 1 62 [(Node 0 63 [])]), (Node 0 61 [])]), (Node 2 56 [(Node 1 58 [(Node 0 59 [])]), (Node 0 57 [])]), (Node 1 54 [(Node 0 55 [])]), (Node 0 53 [])]), (Node 3 44 [(Node 2 48 [(Node 1 50 [(Node 0 51 [])]), (Node 0 49 [])]), (Node 1 46 [(Node 0 47 [])]), (Node 0 45 [])]), (Node 2 40 [(Node 1 42 [(Node 0 43 [])]), (Node 0 41 [])]), (Node 1 38 [(Node 0 39 [])]), (Node 0 37 [])])]

    // "Benchmarking"
    // (Heap.fromList (DecRange     10)) //      352 RW,     103 Mem Size
    // (Heap.fromList (DecRange    100)) //     4339 RW,     553 Mem Size
    // (Heap.fromList (DecRange   1000)) //    44722 RW,    5053 Mem Size
    // (Heap.fromList (DecRange  10000)) //   449701 RW,   50053 Mem Size
    // (Heap.fromList (DecRange 100000)) //  4499638 RW,       ? Mem Size

    // (Heap.deleteMin.repeat     10 (Heap.fromList (DecRange     10))) //       954 RW,      286 Mem Size
    // (Heap.deleteMin.repeat    100 (Heap.fromList (DecRange    100))) //     33264 RW,     9697 Mem Size
    // (Heap.deleteMin.repeat   1000 (Heap.fromList (DecRange   1000))) //   2381617 RW,   776856 Mem Size
    // (Heap.deleteMin.repeat  10000 (Heap.fromList (DecRange  10000))) // 226493712 RW, 75313881 Mem Size
    // (Heap.deleteMin.repeat 100000 (Heap.fromList (DecRange 100000))) //         x RW,        x Mem Size - Seg Fault :clown:

    // General use
    // (Heap.deleteMin.repeat n heap0_99)
