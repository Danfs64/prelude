//* Binomial Heap

// A Binomial Heap is represented as a list of tree nodes, ordered crescently on rank

// A tree node of a Binomial Heap is composed of:
//   - Its rank, which determines its size and how many children it has;
//   - Its root value, which is lower than the values from its children (The min-heap property);
//   - Its children, represented as a list of tree nodes.

// Based on Chris Okasaki's "Purely Functional Data Structures", Chapter 6.2.2 - 1996

//* Type definitions:
// type List<A: Type> {
//     List.Nil
//     List.Cons(head: A, tail: List<A>)
// }

// type Node<Key: Type> {
//     (rank: Nat, root: Key, children: List<Node<Key>>)
// }

// type Heap<Key> = List<Node<Key>>

// type Maybe<A: Type> {
//     Maybe.None
//     Maybe.Some(value: A)
// }

// type Pair<A: Type, B: Type> {
//    (fst: A, snd: B)
// }


//* Helper Functions

(Nat.min x y) = (Nat.min.aux (<= x y) x y)
    (Nat.min.aux 1 x y) = x
    (Nat.min.aux 0 x y) = y

(List.reverse ls) = (List.reverse.aux ls Nil)
    (List.reverse.aux  Nil        acc) = acc
    (List.reverse.aux (Cons x xs) acc) = (List.reverse.aux xs (Cons x acc))

(Pair.fst (Pair fst _)) = fst
(Pair.snd (Pair _ snd)) = snd

(Pair.apply (Pair fst snd) fn) = (fn fst snd)

// Decides if x is Greater, Lesser, or Equal to y
(Battleship x y) = (Battleship.aux (< x y) (> x y))
    (Battleship.aux 1 _) = Lesser
    (Battleship.aux 0 1) = Greater
    (Battleship.aux 0 0) = Equal

// Decreasing Range:
// Creates a range from n-1 to 0
(DecRange 0) = Nil
(DecRange n) =
    let dec = (- n 1)
    (Cons dec (DecRange dec))


//* "Getters"

// Rank(n: Node<Key>) -> Pair(Nat, Node<Key>)
(Node.rank (Node rank root children)) = (Pair rank (Node rank root children))
// Root(n: Node<Key>) -> Pair(Key, Node<Key>)
(Node.root (Node rank root children)) = (Pair root (Node rank root children))
// Children(n: Node<Key>) -> Heap<Key>
(Node.children (Node rank root children)) = children
// Children(n: Node<Key>) -> Pair(Heap<Key>, Node<Key>)
// (Node.children (Node rank root children)) = (Pair children (Node rank root children))


//* Heap Functions

// Links together two trees with the same rank
// The tree returned will be the tree with smaller root with:
//   - the other tree as one of its children
//   - its rank increased by 1
// Link(n1: Node, n2: Node) -> Node
(Heap.link n1 n2) =
    (Pair.apply (Node.root n1) @n1_root@n1_copy
    (Pair.apply (Node.root n2) @n2_root@n2_copy
    (Heap.link.aux (<= n1_root n2_root) n1_copy n2_copy)))

(Heap.link.aux 1 (Node r1 x1 c1) n2) = (Node (+ r1 1) x1 (Cons n2 c1))
(Heap.link.aux 0 n1 (Node r2 x2 c2)) = (Node (+ r2 1) x2 (Cons n1 c2))

// Inserts a Tree into the heap
// P.S.: Do not call it manually, you could break the heap structure
// InsertTree(new: Node, pq: Heap) -> Heap
(InsertTree new  Nil)        = (Cons new Nil)
(InsertTree new (Cons x xs)) =
    (Pair.apply (Node.rank new) @new_rank@new_copy
    (Pair.apply (Node.rank x)   @x_rank  @x_copy 
    (InsertTree.aux (< new_rank x_rank) new_copy (Cons x_copy xs))))

(InsertTree.aux 1 new  xs        ) = (Cons new xs)
(InsertTree.aux 0 new (Cons x xs)) = (InsertTree (Heap.link new x) xs)

// Inserts a key into the heap
// It does so by creating a Node with the key and calling InsertTree
// Insert(x: Key, pq: Heap<Key>) -> Heap<Key>
(Heap.insert x pq) = (InsertTree (Node 0 x Nil) pq)

// Merge together two heaps
// Merge(pq1: Heap, pq2: Heap) -> Heap
(Heap.merge pq Nil) = pq
(Heap.merge Nil pq) = pq
(Heap.merge (Cons x xs) (Cons y ys)) =
    (Pair.apply (Node.rank x) @x_rank@x_copy
    (Pair.apply (Node.rank y) @y_rank@y_copy
    (Heap.merge.aux
        (Battleship x_rank y_rank)
        (Cons x_copy xs)
        (Cons y_copy ys)
    )))

(Heap.merge.aux Lesser  (Cons x xs) (Cons y ys)) = (Cons x (Heap.merge xs (Cons y ys)))
(Heap.merge.aux Greater (Cons x xs) (Cons y ys)) = (Cons y (Heap.merge (Cons x xs) ys))
(Heap.merge.aux Equal   (Cons x xs) (Cons y ys)) = (InsertTree (Heap.link x y) (Heap.merge xs ys))

// Finds the minimal element of the heap
// Returns Maybe.none if the heap is empty
// FindMin(pq: Heap<Key>) -> Maybe<Key>
(Heap.findMin  Nil       ) = Maybe.None
(Heap.findMin (Cons t ts)) =
    let t_root = (Pair.fst (Node.root t))
    (Maybe.Some (Heap.findMin.aux ts t_root))

(Heap.findMin.aux  Nil        n) = n
(Heap.findMin.aux (Cons t ts) n) =
    let t_root = (Pair.fst (Node.root t))
    let min    = (Nat.min n t_root)
    (Heap.findMin.aux ts min)

// Removes the minimal element of the heap
// Returns an empty heap if the heap is already empty
// DeleteMin(pq: Heap) -> Heap
(Heap.deleteMin Nil) = Nil
(Heap.deleteMin pq)  =
    let get_min = (Heap.getMin pq)
    (Pair.apply get_min @removed@new_pq
    (Heap.merge (List.reverse (Node.children removed)) new_pq))

// Returns a pair of:
//   - the tree with the minimal element;
//   - the input heap without said tree;
// GetMin(pq: Heap<Key>) -> Pair<Node<Key>,Heap<Key>>
(Heap.getMin (Cons x Nil)) = (Pair x Nil)
(Heap.getMin (Cons x xs )) =
    let rec = (Heap.getMin xs)
    let rec_node = (Pair.fst rec)
    (Pair.apply (Node.root x)        @x_root  @x_copy
    (Pair.apply (Node.root rec_node) @rec_root@rec_copy
    (Heap.getMin.aux (<= x_root rec_root) (Cons x_copy xs) rec)))

(Heap.getMin.aux 1 (Cons x xs) rec) = (Pair x xs)
(Heap.getMin.aux 0 (Cons x xs) rec) = 
    (Pair.apply rec @node@pq
    (Pair node (Cons x pq)))

// Creates a heap using a list of natural numbers
// Heap.fromList(xs: List<Key>) -> Heap<Key>
(Heap.fromList xs) = (Heap.fromList.aux xs Nil)
    (Heap.fromList.aux  Nil        pq) = pq
    (Heap.fromList.aux (Cons x xs) pq) = (Heap.fromList.aux xs (Heap.insert x pq))


(Main n) =
    // Some vars
    let heap1 = (Heap.fromList [1,2,3,4,5])
    let heap2 = (Heap.fromList [6,7,8,9,10,11,12])
    let heap3 = (Heap.fromList [0,13,14,15,16,17])
    let heapmaster = (Heap.merge heap3 (Heap.merge heap1 heap2))

    // Testing Constructors/Functions
    // heap2
    // heapmaster
    // (Heap.findMin heapmaster)
    // (Heap.deleteMin heapmaster)

    // "Benchmarking"
    // (Heap.fromList (DecRange 10))     //      352 RW,      253 Mem Size
    // (Heap.fromList (DecRange 100))    //     4339 RW,     2563 Mem Size
    // (Heap.fromList (DecRange 1000))   //    44722 RW,    25909 Mem Size
    // (Heap.fromList (DecRange 10000))  //   449701 RW,   259897 Mem Size
    // (Heap.fromList (DecRange 100000)) // 56346413 RW, 66616128 Mem Size

    // General use
    // (Heap.fromList (DecRange n))
    // (Heap.findMin (Heap.fromList (DecRange n)))
    // (Heap.deleteMin (Heap.deleteMin (Heap.deleteMin (Heap.deleteMin heapmaster))))
